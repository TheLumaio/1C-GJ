/* please no steal thx
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::.::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.::::
:::::::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.:::.::::::
::::::::.::::.::::.::::::.::::.:                                          :::.::::.::::::.::::.::::::.::::.::::::.::::.::::::.::::.::::::.::::.:::::::
::.:::::::::::::.:::::::::::.:    :::::::::::::::ccccccccccccccccccccccccc     :.:::::::::::.:::::::::::.:::::::::::.:::::::::::.:::::::::::.:::::.:::
:::::.:::::.::::::::::::.:::::  :::::::::::::::::cccccccccccccccccccccccccccccc      :::.:::::::::::.:::::::::::.:::::::::::.:::::::::::.::::::::::::.
:::::::::.::::::::::::.:::::  :::::::::::::::::::cccccccccccccccccccccccccccccccccccc  ::::::.::.::::::::.::.::::::::.::.::::::::.::.::::::::.:::.::::
::.::.::::::.:::::::.::::.::  :::::::::::::::::::CCCCCCCCocc:ccc:ccc:ccc:ccc:cccccccccc    .::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:::::::::::::::.::.::::.::  :::::::::::cc:cc:c:ccCCCCCCCCCCCCCCCcccccccccccccccc:cccccccccc.    :::::.:::.:::::::.:::.:::::::.:::.:::::::.:::.::::::::
:::::::::::::::::::::.::::  ::::::::::cccccccccccooooooCCCCCCCCCooccc:cccc:cccccccccccccccc:.... . .:::.:::.::.::::.:::.::.::::.:::.::.::::.::::::.:::
::.::::::.:::::.::::::::::  ::::::::cccc:ccc:ccccccccccoCCCCCCCCCCccccccccccccc:ccccccc:cccccccc    :::::::::::::.:::::::::::.:::::::::::.::::.:::::::
:::::.::::::::::::.:::::::  ::::::::ccccccccc:::::cccCCCCCCCcccccccccccccccccccccccccccccccccccccccc    .::::::::::::::::::.:::::::::::.::::.:::::::::
:::::::::::.::.::::::::   :::::::::::ccc:cccccc:cCCCCCCCCoccccccccccccc:cccccc:ccccccccccccccc:ccccccccc.   :.::::::::::.::::::::::.::::::.::::.::::::
::.::.:::::::::::::.:. ::::::::::::::::::::::ccccCCCCCCoccccccccccccccccccccccccccc:cccc:ccccccccccccccccccc     :::.::::::::::::::::::::::::.::::::.:
:::::::::.:::::.:::::  ::::::::::::::::::::ccc:ccCCCCCCCCCCCCCccccccccccccccccccccccccccccccccccccccccccccccccccc    ::::.::.::::::.:::::.:::::.::::::
:::::::::::::::::    .:::::::::::::::::::cccccc::ccccCCCCCCCCCccccccccccccc:ccccccccccccccccccccccc:ccccccccccccccccc    :::::::::::::::::::::::::::.:
::.::.::.::::    :::::::::::::::::::::::ccccc::::cccccccccccCCccccccc:ccccccccccccccc:cccccc:cccccccccccccccccccccccccccc    .:.::::.::::::::.::.:::::
:::::::::    ::::::::::::::::::::::::::::::::::::ccccccccccccccccccccccccccccccccc:cccccccccccccccccccccccccccccccccccccccccc.                   :::::
:::::::::  :::::::::::::::::::::::::::::::::::::::ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc:cccccccccccccccccccccccccccccccc   :.:::
::.::.:::  ::::::::::::::::::::::::::::::::::::::ccccc:ccccccccccccccccccc:ccc:cccccccccccc:ccccccccccccc:cccccccccccccccccc:ccccccccccccccc. ::::::::
:::::::.:::  :::::::::::::::::::::::::::::::::::::cccccccccccccccccccc:ccccccccccccccccccccccccccccccccccccccccccccccccccccccccc:ccc:ccc:c  .::.::.::.
:::::::::::::  :::::::::::::::::::::::::::::::::::::::::::::::::::cccccccccccccccccc:cccccccccccccccccc:ccccc:cccccccccccccccccccccccccc  ::::::::::::
::.:::::::.::::  :::::::::::::::::::::::::::::::::::::::::::::::::::::::ccccccccc:ccccccccccccccccccccccccccccccccccccccccccc:cccccccc  :::::.::::::::
:::::.::.:::.::::    .:::::::::::::::::::::::::::                       ::ccc:ccccccccccccccc:cccccccccccccccccccccccccccccccccccc    ::::::::::::.:::
:::::::::::::.:::::::     :::::::::::::::::::::  cccccccccccccoooooooooo         cccccccccccccccccccccccccccccccc:cccccccccccccc  ::::::::::::::::::.:
::.::.:::::::::::::.::::::      :::::::::::::  cccccccccccccccooooooooooooooooooo    cccccccccccccccccccccccccccccccccccccc     ::::.::::.::::::::.:::
:::::::::.::::::::::::::.:...................  cccccccccccccooooooooooooooooooooo::  ccccccccccccccccccccccccc:cccccccccc.......::.::::.::::.:::::::::
::::::::::::.::::::.::.::::::.::               cccccccccccccooooooooooooooooooooooo  ccc:ccccc:cccc:cccc:cccccccccccc:ccc  :::::::::::::::.:::::::::::
::.::::::.:::::::.::::::.::::::::::::::::::    ccccccccccoooooooooooOOCoooooooooooo  cccccccccccccccccccccccccccc        :::::::.::::::.::::.::.::::::
:::::.:::::::::::::.:::::::::::::::::::::::  88ccccccccccoooooooooOOOOOOooooooooooo                              ::::::::.::::.:::::.::::.::::::::::.:
::::::::::.::.:::::::::.:::::::.::::.:     888888cc    :ooooooooOOOOOOCoooooooooo    :::::::::::::::::::::  ::::::.::::.:::::::::::::::.::::::::::::::
::.:::.::::::::::::::.:::::::.::::::  ..   cc88cc      ..cooooooooOOooooooooooo  :::::.::.::.::.::.::.::.:::   :::::::::::::::::.::.:::::::::::.::.:::
:::::.::::::.:::::::::::.:::::::.:  .......  cccc    .......oooooooooooooo     ::::::.::::.:::::.:::::.:::.::::  ::::::::.::::::::::::::.::.:::::::::.
:::::::::::::::.::::::.::::::.::::  .......  cccc    .......oooooooooooo  :::::::::::::::::::::::::::::::::.:::::  ::.:::::::::::::::.::::::::::.:::::
::.::.:::::.::::::.::::::.::::::  .. ...... .  cccc    ..cooooooooCooo: :.:::::::::::::.:::::::.:::::.:::::::::.:  :::.:::::::::::.::::::::.::::::::::
::::::::::::::::.:::::::::::::  .. ... ......  ccccccccooooooooooooo  .::::::::.:::::::::::::::::.::::::::.::::::::  ::::::.:::::::::::::::::::::.::::
::::::::::::.::::::.::::::.:::  .... ... .. .  ccccccccooooooooooo  :::::::::::::::::::::::::::::::::.::::::::::.::::  :::::::.::.:::::.::::::::::::::
::.::.::.::::::::::::.::.:::  ........ ........  ccccccooooooooooo  :::::.:::.::.::::.::.::::::.::::::::.:::           ::::::::::::::::::::::.::::.:::
::::::::::::::::::::::::::::  .................  OOOOOOOO8@@@@@@oo  ::.::::::::::::.::::::.:::::::::::::::  ::::::::::::::::::::.::::::::::::::::::::.
:::::::::::::.:::.:::.::::  .. ..... ....... ....  OOOOOOOOO@@@@  ::.::::.::::::::::::::::::::::::::::::. :::::.:::.::::::.::.::::::.:::.::.:::::::.::
::.::.::.::.:::::::::::.::  .... .. ..... .. ....  OOOOOO8@@@@@@  :::::.:::::.::.::::.:::.::::::.:::::::. :::::::::::.:::::::::::::::::::::::::.::::::
::::::::::::::::::::::::::  ............. ... . .  ccccooooooooo  :::::::::::::::::.::::::::::.::::.::::. ::.::::::::::.:::.::::::.:::::::::::::::::::
::::::::::::::::::.::::.::  ........... ... .....  ccccooooooo  ::::.::::::.::.::::::::.::.:::::::::::  .:::::::::::::.::::::::.::::::.:::::::.::.::::
::.::.::.::.::::::::::::::  .... .... .. ... ....  ccccooooooo  ::::::::.:::::::::::.::::::::::.::::.:  .:::::::.::.:::::::::::::::::::::.::.:::::::::
:::::::::::::::::::.:::.::  .. ... .. .... .... .  ccccooooooo  :.::::::::::::::.:::::::.::.::::::::.....:::::.::::::::::.:::.::::::.::::::::::.::::::
:::::::::::::.::::::::::::  ... ... .. ..........  ccccooooooo  ::::::::.:::.::::::::.:::::::::::.::  :::.::.::::::::::::::.:::::.::::::::.:::::::.:::
::.::.::.:::::::.:::.:::::  ..... .. .... ..... .  ccccooooooo  ::::::.:::.::::::.:::::::::::.::::::  :::::::::.::.:::::::::::::::::::::::::::::.:::::
::::::::::::::.:::::::::::  .. ... ........ .....  ccccooooooo  ::.:::::::::::.:::::::.::.::::::::.:  :::::::::::::.::.::::.:::::::::::.:::.:::::::.::
::::::::::::::::::::::::::  ... ....... ..... ...               ::::::::::::::::::.:::::::::::::.:  ::::.:::.::::::::::::::::::::::::.::::::::::.:::::
::.::.::.::::::.::.:::::::  .............. .. ..... ... ......::::::::::::::::::.:::::::.::.::.:::  ::.:::.:::::.::.:::::.::::::::::::::::::::::::::::
::::::::::::::::::::::::::  .. ......... .. .... .... ... .....:.::::.::::::::::::::.:::::::::::  ::::::.::::::::::::::.:::::::::::::::::::::::.::::::
:::::::::::::::::::.::::::  ... ...... . ... .......... ......:::::::::.:::::::::.::::::::.::.::  ::::::::::::.::::.::::::.:::::::::::::.::.::::::::::
::.::.::.:::.:::.:::::::::  ........ .......... ......... ....:::::.::::::::.::::::::.::::::::::  ::.:::::::::::::::::::::::::::::::::.:::::::::::::::
::::::::::.::::::::.::::::  .. ........... ....... ........ ...::::::::.::::::::::.:::::::.:::  :::::::.::.::.:::::.::::::::::.:::::.::::::::.::.:::.:
::::::::::::.:::::::::::::  ........... ... .. ....... ......::::::::::::::::::::::::.::::::::  ::::::::.::::::::.::::.::.::::::::::::.:::::::::::::::
::.::.::::::::::.::::.::.:::  .. ........ ... .. ........ ...::::::.::.:::::::.::.::::::::.:::  ::.::::::::.::::::::.:::::::::::::::::::::::::::::::::
:::::::.:::::::::::.::::::.:  ........ .... .. ...... .... .:::.::.::::::::.:::::::::::.:::.  :::::::.:::::::::.::.::::::::::::::::::::.::.::::::::.::
:::::::::::.::.:::::::.:::::::  ..... ......... .... .....:.:.:::::::::::::::::::::.:::::::.  ::.:::::::.:::::::::::::::::.::.::::::::::::::::::::::::
::.:::::::::::::::::.::::::.::  ............. ...... .. ..:::::::::.::.::::.::.::.:::::::  .:::::::.::::::::::::.::::::::::::::::::::::.::::::::::.:::
:::::.::.::::::.:::::::.:::::.::  .......... ......... ....::::::::::::::::::::::::::.:::  .:::::::::::.::::::::::::.::::::.:::::.:::::::.::.:::.:::.:
::::::::::.::.:::::::.::::::::::  ........... .......... .::.:::::::.:::::::::.::::::::::   ::::::::::::::.::.:::.::::::.:::::::::::::::::::::::::::::
::.::.::::::::::.:::::::.:::.:::  ............. .... .......:::.::::::::.::.::::.:::.::  ::::::.::.:::.:::::::::::::.::::::.:::::::::::.::::::::::::::
:::::::::.::.:::::::::.:::::::::  .. .... .... ... .... .. .::::::::::::::::::.::::::::  ::.::::.::::::::::.:::::::::::::::::::::.:::.:::::.::.:::.:::
::::::::::::::::::.:::::::::::::.:  ... .... ..                 :.:::.:::::.:::::::::  ::::::::::::::::::::::::.::.:::.:::::::::::::::::::::::::.:::.:
::.::.::.::::::::::::::::::::.::::  . .. ..    :::::::::::::::::    ::::::::::.::::::  :::::::::.:::::::::.:::::::::.:::::.::.::::.:::::::::.:::::::::
:::::::::::::::::.:::::::.::::::.::.  ..   :::::.:::::::::::::::::::      ::.::::::  :::.::::::::::::.::.:::::.::::::::::::::::::::::::::::::::::.::::
:::::::::.:::::.:::::.::::::::::::::::  :::::::::::.::::::::::::.:::::::::         :::.:::::.::::::::::::::.:::::::::::::::.:::::::.:::::.::::.:::::::
::.::.::::::::::::.::::::::.::::::::::::.::::.:::::::::.:::::::::::::.:::::::::::::.::::.:::::::::::.:::::::::.::::::.:::::::::::::::::.:::::::::.::::
:::::::::::::::::::::.:::::::::::.::.::::::::::.:::::::::::.::.::.::::::::::::::::::::.:::::.:::::.:::::::::::::::::::::.:::.::.::.:::::::.:::.:::::::
::::::::::.::.:::.::::::.:::.:::::::::::::::::::::.::::::::::::::::::.:::::.::.::.::::::::.::::::::::.::::::::::.:::.::::::::::::::::::.:::::::::.::::
::.::.::::::::::::::::.:::::::::.::::::::::.::::::::::.::.::::::::::::.::.:::::::::.::::::::.::::::::::::.:::::::::::::::::::::::.::::::::::::::::::::
:::::::::::.:::::::::::::::::::::::::::::.::::::::::::::::::.::::::::::::::::::::::::::::.::::::::.:::::::::::::.:::::::::.::::::::.:::.::::::.::.::::
:::::::::::::::.:::.::::::::.::::.::.::.::::.:::::::::.::::::::::.::.:::::::::::.::::::.::::.::::::::::::::::::::::::::::::::::::::::.::::::::::::::::
*/



#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <string.h>

#include <raylib.h>
#include <raymath.h>

#define GAME_LIST      -1
#define GAME_SCORES     0
#define GAME_SNAKE      1
#define GAME_BREAKOUT   2
#define GAME_MISSILES   3

// breakout
#define BO_X    0
#define BO_Y    1
#define BO_FLAG 2

// missile commander
#define MISSILE_X     0
#define MISSILE_Y     1
#define MISSILE_TOX   2
#define MISSILE_FLAG  3
#define MISSILE_SPEED 4
#define MISSILE_FROMX 5
#define MISSILE_TOY   6

#define CITY_X    0
#define CITY_FLAG 1

// scores
#define SCORE_SNAKE    0
#define SCORE_BREAKOUT 1
#define SCORE_MISSILES 2

static Model cabinet_model;
static Model cabinet_joystick;
static Model cabinet_screen;
static Camera camera;

static RenderTexture2D cabinet_target;
static RenderTexture2D cabinet_buffer;
static int current_game = GAME_LIST;
static bool playing = false;

static int highscores[3] = {0};

void dump_scores()
{
    FILE* f = fopen("scores", "w");
    for (int i = 0; i < 3; i++)
        fprintf(f, "%d\n", highscores[i]);
    fclose(f);
}

void read_scores()
{
    char* t = LoadText("scores");
    char* s = strtok(t, "\n");
    int i = 0;
    while (s) {
        highscores[i] = atoi(s);
        s = strtok(NULL, "\n");
        i++;
    }
}

bool check_collide(float x1, float y1, float w1, float h1, float x2, float y2, float w2, float h2)
{
    bool c = false;
    float dx = fabs((x1+w1/2.f) - (x2+w2/2.f));
    float dy = fabs((y1+h1/2.f) - (y2+h2/2.f));
    if ((dx <= (w1/2.f + w2/2.f)) && ((dy <= (h1/2.f + h2/2.f)))) c = true;
    return c;
}

float distance(float x1, float y1, float x2, float y2)
{
    return sqrt(pow(x2-x1,2)+pow(y2-y1,2));
}

void game_list()
{
    static int selection = 0;
    /* Instead of wrapping updates in a separate function I just check if you're playing in each game update */
    if (playing) {
        if (IsKeyPressed(KEY_DOWN))
            selection = (selection+1)%4;
        if (IsKeyPressed(KEY_UP)) {
            selection--;
            if (selection < 0) selection = 3;
        }
        if (IsKeyPressed(KEY_ENTER))
            current_game = selection;
    }
    
    DrawRectangle(100, 150+selection*40, 300, 40, BLACK);
    DrawRectangleLines(100, 150+selection*40, 300, 40, WHITE);
    DrawRectangleLines(100-1, 150+selection*40-1, 300+2, 40+2, WHITE);
    DrawRectangleLines(100-2, 150+selection*40-2, 300+4, 40+4, WHITE);
    
    DrawText("HIGHSCORES", 100, 150, 40, GREEN);
    DrawText("SNAKE", 100, 150+40, 40, GREEN);
    DrawText("BREAKOUT", 100, 150+40+40, 40, GREEN);
    DrawText("MISSILES", 100, 150+40+40+40, 40, GREEN);
}

void game_scores()
{
    if (playing) {
        if (IsKeyPressed(KEY_Q))
            current_game = GAME_LIST;
    }
    
    DrawText(FormatText("Snake: %d", highscores[SCORE_SNAKE]), 150, 200, 40, WHITE);
    DrawText(FormatText("Breakout: %d", highscores[SCORE_BREAKOUT]), 150, 200+50, 40, WHITE);
    DrawText(FormatText("Missiles: %d", highscores[SCORE_MISSILES]), 150, 200+50+50, 40, WHITE);
    
    DrawText("Q TO RETURN", 50, 400, 40, GREEN);
}

void game_snake()
{
    static bool snake_initialized = false;
    static int board[16][16];
    static int food_on_board = 0;
    static const int max_food = 1;
    static int head_x = 10;
    static int head_y = 8;
    static int tail_x = 7;
    static int tail_y = 8;
    static float elapsed = 0.f;
    static char direction = 'e';
    static const int grow_amount = 1;
    static int grow = 0;
    static bool dead = false;
    static int score = 0;
    static bool need_update = false;
    
    if (!snake_initialized) {
        head_x = 10;
        head_y = 8;
        tail_x = 7;
        tail_y = 8;
        direction = 'e';
        score = 0;
        grow = 0;
        elapsed = 0;
        dead = false;
        need_update = false;
        
        for (int i = 0; i < 16; i++)
            for (int j = 0; j < 16; j++)
                board[i][j] = 0;
        for (int i = tail_x; i <= head_x; i++) {
            board[i][head_y] = 'e';
        }
        
        int a=rand()%16;
        int b=rand()%16;
        while (board[a][b] != 0) {
            a=rand()%16;
            b=rand()%16;
        }
        board[a][b] = 1;
        
        snake_initialized = true;
    }
    
    if (playing) {
        elapsed += GetFrameTime();
        
        if (IsKeyPressed(KEY_Q))
            current_game = GAME_LIST;
        
        if (!dead) {
            if (IsKeyPressed(KEY_UP) && direction != 's' && direction != 'n') {
                elapsed = 0;
                board[head_x][head_y] = 'n';
                head_y--;
                direction = 'n';
                need_update = true;
            }
            
            if (IsKeyPressed(KEY_DOWN) && direction != 's' && direction != 'n') {
                elapsed = 0;
                board[head_x][head_y] = 's';
                head_y++;
                direction = 's';
                need_update = true;
            }
            
            if (IsKeyPressed(KEY_LEFT) && direction != 'e' && direction != 'w') {
                elapsed = 0;
                board[head_x][head_y] = 'w';
                head_x--;
                direction = 'w';
                need_update = true;
            }
            
            if (IsKeyPressed(KEY_RIGHT) && direction != 'e' && direction != 'w') {
                elapsed = 0;
                board[head_x][head_y] = 'e';
                head_x++;
                direction = 'e';
                need_update = true;
            }
            if (head_x<0||head_x>15||head_y<0||head_y>15 || (need_update && board[head_x][head_y] > 1)) {
                printf("SNEK DED\n");
                dead = true;
                if (score > highscores[SCORE_SNAKE]) {
                    highscores[SCORE_SNAKE] = score;
                    dump_scores();
                }
            }
        } else {
            if (IsKeyPressed(KEY_R))
                snake_initialized = false;
        }
    }
    
    if (elapsed > 0.1) {
        elapsed = 0;
        switch (direction) {
            case 'n':
                if (head_y-1<0) {
                    dead = true;
                    if (score > highscores[SCORE_SNAKE]) {
                        highscores[SCORE_SNAKE] = score;
                        dump_scores();
                    }
                    break;
                }
                board[head_x][head_y] = 'n';
                head_y--;
                if (board[head_x][head_y] > 1) {
                    dead = true;
                    if (score > highscores[SCORE_SNAKE]) {
                        highscores[SCORE_SNAKE] = score;
                        dump_scores();
                    }
                    break;
                }
                need_update = true;
                break;
            case 'e':
                if (head_x+1>15) {
                    dead = true;
                    if (score > highscores[SCORE_SNAKE]) {
                        highscores[SCORE_SNAKE] = score;
                        dump_scores();
                    }
                    break;
                }
                board[head_x][head_y] = 'e';
                head_x++;
                if (board[head_x][head_y] > 1) {
                    dead = true;
                    if (score > highscores[SCORE_SNAKE]) {
                        highscores[SCORE_SNAKE] = score;
                        dump_scores();
                    }
                    break;
                }
                need_update = true;
                break;
            case 's':
                if (head_y+1>15) {
                    dead = true;
                    if (score > highscores[SCORE_SNAKE]) {
                        highscores[SCORE_SNAKE] = score;
                        dump_scores();
                    }
                    break;
                }
                board[head_x][head_y] = 's';
                head_y++;
                if (board[head_x][head_y] > 1) {
                    dead = true;
                    if (score > highscores[SCORE_SNAKE]) {
                        highscores[SCORE_SNAKE] = score;
                        dump_scores();
                    }
                    break;
                }
                need_update = true;
                break;
            case 'w':
                if (head_x-1<0) {
                    dead = true;
                    if (score > highscores[SCORE_SNAKE]) {
                        highscores[SCORE_SNAKE] = score;
                        dump_scores();
                    }
                    break;
                }
                board[head_x][head_y] = 'w';
                head_x--;
                if (board[head_x][head_y] > 1) {
                    dead = true;
                    if (score > highscores[SCORE_SNAKE]) {
                        highscores[SCORE_SNAKE] = score;
                        dump_scores();
                    }
                    break;
                }
                need_update = true;
                break;
            default:
                break;
        }
        
    }
    
    if (need_update && !dead)
    {
        if (board[head_x][head_y] == 1) {
            grow = grow_amount;
            score++;
            int a=rand()%16;
            int b=rand()%16;
            
            while (board[a][b] != 0) {
                a=rand()%16;
                b=rand()%16;
            }
            board[a][b] = 1;
        }
        board[head_x][head_y] = 2;
        
        /* pop tail */
        if (grow > 0)
            grow--;
        else {
            int a=tail_x,b=tail_y;
            switch (board[tail_x][tail_y]) {
                case 'n':
                    tail_y--;
                    break;
                case 'e':
                    tail_x++;
                    break;
                case 's':
                    tail_y++;
                    break;
                case 'w':
                    tail_x--;
                    break;
                default:
                    break;
            }
            board[a][b] = 0;
        }
        need_update = false;
    }
    
    if (!dead) {
        for (int i = 0; i < 16; i++) {
            for (int j = 0; j < 16; j++) {
                Color c = BLUE;
                if (board[i][j] == 0) c = WHITE;
                if (board[i][j] == 1) c = GREEN;
                DrawRectangle(100+i*20, 100+j*20, 15, 15, c);
            }
        }
        DrawText(FormatText("Score: %d", score), 150, 475, 40, GREEN);
    } else {
        DrawText("You died", 100, 150, 40, RED);
        DrawText(FormatText("Score: %d", score), 100, 200, 40, RED);
        DrawText("R to restart", 100, 250, 40, GREEN);
        DrawText("Q to exit", 100, 300, 40, GREEN);
    }
}

void game_breakout()
{
    static bool breakout_initalized = false;
    static const int width = 6;
    static const int height = 6;
    static int blocks[width*height][3];
    static float ball_x;
    static float ball_y;
    static float bvel_x;
    static float bvel_y;
    static int paddle_width;
    static float paddle_x;
    static bool stuck;
    static bool dead = false;
    static int difficulty = 1;
    static int score;
    static int blocks_left;
    
    if (!breakout_initalized) {
        ball_x = 0;
        ball_y = 0;
        paddle_width = 100;
        paddle_x = 256-paddle_width/2;
        stuck = true;
        bvel_x = 0;
        bvel_y = 100;
        dead = false;
        blocks_left = width*height;
        
        for (int i = 0; i < width*height; i++) {
            int a = i%width;
            int b = i/width;
            
            blocks[i][BO_X]    = 75+a*60; // X
            blocks[i][BO_Y]    = 75+b*20; // Y
            blocks[i][BO_FLAG] = 1+rand()%difficulty; // FLAG (number of hits required to break)
        }
        
        breakout_initalized = true;
    }
    
    if (playing) {
        if (IsKeyPressed(KEY_Q))
            current_game = GAME_LIST;
        
        if (!dead) {
            if (IsKeyDown(KEY_LEFT))
                paddle_x -= 300*GetFrameTime();
            if (IsKeyDown(KEY_RIGHT))
                paddle_x += 300*GetFrameTime();
            if (IsKeyPressed(KEY_SPACE) && stuck)
                stuck = false;
        } else {
            if (IsKeyPressed(KEY_R)) {
                breakout_initalized = false;
                difficulty = 1;
                score = 0;
            }
        }
        
    }
    
    if (dead) goto B_DEAD; /* because im lazy */
    
    for (int i = 0; i < width*height; i++)
    {
        if (blocks[i][BO_FLAG] == 0) continue;
        int f = blocks[i][BO_FLAG];
        Color c = WHITE;
        if (f == 2) c = GREEN;
        if (f == 3) c = BLUE;
        if (f == 4) c = YELLOW;
        DrawRectangle(blocks[i][BO_X], blocks[i][BO_Y], 55, 15, c);
    }
    
    if (stuck) {
        ball_x = paddle_x+paddle_width/2-10;
        ball_y = 450-20;
    } else {
        if (bvel_x > 300) bvel_x = 300;
        if (bvel_y > 300) bvel_y = 300;
        if (bvel_x < -300) bvel_x = -300;
        if (bvel_y < -300) bvel_y = -300;
        
        ball_x += bvel_x*GetFrameTime();
        ball_y += bvel_y*GetFrameTime();
        
        /* Edge collision detection */
        if (ball_x < 0) {
            bvel_x = -bvel_x;
            ball_x = 0;
        }
        if (ball_x+20 > 512) {
            bvel_x = -bvel_x;
            ball_x = 512-20;
        }
        if (ball_y < 0) {
            bvel_y = -bvel_y;
            ball_y = 0;
        }
        if (ball_y+20 > 512) {
            dead = true;
            if (score > highscores[SCORE_BREAKOUT]) {
                highscores[SCORE_BREAKOUT] = score;
                dump_scores();
            }
            goto B_DEAD;
        }
        
        /* Paddle collision detection */
        bool c_paddle = false;
        c_paddle = check_collide(ball_x, ball_y, 20, 20, paddle_x, 450, paddle_width, 15);
        if (c_paddle) {
            if (bvel_x < 0) bvel_x -= 50;
            else bvel_x += 50;
            if (bvel_y < 0) bvel_y -= 50;
            else bvel_y += 50;
            
            
            bvel_y = -bvel_y;
            if (bvel_x == 0) bvel_x = 100;
            if (ball_x+10 < paddle_x+paddle_width/2)
                bvel_x = -fabs(bvel_x);
            else
                bvel_x = fabs(bvel_x);
            
            if (ball_y < 450)
                ball_y = 450-20;
            else
                ball_y = 450;
        }
        
        /* Block collision detection */
        float dx = ball_x+10;
        float dy = ball_y+10;
        
        for (int i = 0; i < width*height; i++)
        {
            if (blocks[i][BO_FLAG] == 0) continue;
            int x = blocks[i][BO_X];
            int y = blocks[i][BO_Y];
            
            if (check_collide(x, y, 55, 15, ball_x, ball_y, 20, 20)) {
                blocks[i][BO_FLAG]--;
                if (blocks[i][BO_FLAG] == 0) {
                    blocks_left--;
                    score++;
                }
                if (dy < y || dy > y+15) {
                    bvel_y = -bvel_y;
                    break;
                }
                if (dx < x || dx > x+55) {
                    bvel_x = -bvel_x;
                    break;
                }
                break;
            }
            
        }
        
        if (blocks_left == 0) {
            stuck = true;
            bvel_x = 0;
            bvel_y = 100;
            if (difficulty < 4) difficulty++;
            breakout_initalized = false;
        }
        
    }
    
    DrawText(FormatText("Score: %d", score), 150, 475, 40, GREEN);
    DrawRectangle(ball_x, ball_y, 20, 20, (Color){0, 255, 255, 255});
    DrawRectangle(paddle_x, 450, paddle_width, 15, WHITE);
    
    B_DEAD:
    if (dead) {
        DrawText("You died", 100, 150, 40, RED);
        DrawText(FormatText("Score: %d", score), 100, 200, 40, RED);
        DrawText("R to restart", 100, 250, 40, GREEN);
        DrawText("Q to exit", 100, 300, 40, GREEN);
    }
}

void game_missiles()
{
    static bool missiles_initialized = false;
    static float missiles[12][6]; // x y bx f s a
    static float rockets[8][7]; // x y bx f s a
    static int difficulty = 0;
    static float cursor_x = 512/2;
    static float cursor_y = 512/2;
    static int cities[3][2]; // x f
    static float spawn_timer = 5;
    static const int city_width = 75;
    static int rockets_left = 0;
    static bool new_wave = false;
    static int spawn_rockets = 0;
    static int score = 0;
    static bool dead = false;
    
    if (!missiles_initialized) {
        cities[0][CITY_X] = 512/2-512/3;
        cities[1][CITY_X] = 512/2;
        cities[2][CITY_X] = 512/2+512/3;
        cities[0][CITY_FLAG] = 1;
        cities[1][CITY_FLAG] = 1;
        cities[2][CITY_FLAG] = 1;
        
        new_wave = false;
        dead = false;
        
        difficulty = 0;
        spawn_timer = 5;
        spawn_rockets = 0;
        rockets_left = 0;
        score = 0;
        for (int i = 0; i < 12; i++)
            for (int j = 0; j < 6; j++)
                missiles[i][j] = 0;
        for (int i = 0; i < 8; i++)
            for (int j = 0; j < 7; j++)
                rockets[i][j] = 0;
            
        missiles_initialized = true;
    }
    
    if (playing) {
        if (IsKeyPressed(KEY_Q))
            current_game = GAME_LIST;
        
        if (!dead) {
            
            if (IsKeyDown(KEY_RIGHT))
                cursor_x += 300*GetFrameTime();
            if (IsKeyDown(KEY_LEFT))
                cursor_x -= 300*GetFrameTime();
            if (IsKeyDown(KEY_UP))
                cursor_y -= 300*GetFrameTime();
            if (IsKeyDown(KEY_DOWN))
                cursor_y += 300*GetFrameTime();
            
            if (IsKeyPressed(KEY_SPACE) && rockets_left > 0 && spawn_timer == 0) {
                for (int i = 0; i < 8; i++) {
                    if (rockets[i][MISSILE_FLAG] == 0) {
                        
                        rockets[i][MISSILE_X] = 0;
                        rockets[i][MISSILE_Y] = 450;
                        if (cursor_x > 256)
                            rockets[i][MISSILE_X] = 512;
                        
                        rockets[i][MISSILE_TOX] = cursor_x;
                        rockets[i][MISSILE_TOY] = cursor_y;
                        
                        rockets[i][MISSILE_FLAG] = 1;
                        rockets[i][MISSILE_SPEED] = 400;
                        rockets[i][MISSILE_FROMX] = rockets[i][MISSILE_X];
                        
                        rockets_left--;
                        
                        break;
                    }
                }
            }
        } else {
            if (IsKeyPressed(KEY_R))
                missiles_initialized = false;
        }
    }
    if (dead) goto M_DEAD;
    
    if (new_wave && spawn_timer == 0) {
        for (int i = 0; i < 3+difficulty; i++) {
            missiles[i][MISSILE_X] = 20+rand()%(512-40);
            missiles[i][MISSILE_Y] = 0;
            
            int c = rand()%3;
            while (cities[c][CITY_FLAG] < 1)
                c = rand()%3; // choose a city to fire at
            
            int a = (cities[c][CITY_X]-city_width/2)+rand()%city_width; // create an offset
            float r = atan2(450, a-missiles[i][0]);
            missiles[i][MISSILE_TOX] = a;
            missiles[i][MISSILE_FLAG] = 1;
            missiles[i][MISSILE_SPEED] = 25+rand()%(15*(difficulty+1));
            missiles[i][MISSILE_FROMX] = missiles[i][MISSILE_X];
        }
        rockets_left = 3+difficulty+2;
        new_wave = false;
    }
    
    if (spawn_timer > 0) {
        DrawText(FormatText("Spawning in: %.0f", spawn_timer), 125, 200, 40, WHITE);
        spawn_timer -= GetFrameTime();
    } else if (spawn_timer < 0) {
        spawn_timer = 0;
        new_wave = true;
    } else {
        DrawText(FormatText("Score: %d\n", score), 125, 200, 40, DARKGRAY);
        DrawText(FormatText("Rockets: %d\n", rockets_left), 125, 250, 40, DARKGRAY);
    }
    
    for (int i = 0; i < 8; i++) {
        if (rockets[i][MISSILE_FLAG] == 1) {
            float r = atan2(rockets[i][MISSILE_TOY]-rockets[i][MISSILE_Y], rockets[i][MISSILE_TOX]-rockets[i][MISSILE_X]);
            rockets[i][MISSILE_X] += cos(r)*rockets[i][MISSILE_SPEED]*GetFrameTime();
            rockets[i][MISSILE_Y] += sin(r)*rockets[i][MISSILE_SPEED]*GetFrameTime();
            
            float d = distance(rockets[i][MISSILE_X], rockets[i][MISSILE_Y], rockets[i][MISSILE_TOX], rockets[i][MISSILE_TOY]);
            if (d < 4) {
                rockets[i][MISSILE_FLAG] = 2;
            }
            DrawLine(rockets[i][MISSILE_FROMX], 450, rockets[i][MISSILE_X], rockets[i][MISSILE_Y], GREEN);
        } else if (rockets[i][MISSILE_FLAG] > 1) {
            rockets[i][MISSILE_FLAG] += 50*GetFrameTime();
            float d = rockets[i][MISSILE_FLAG];
            if (rockets[i][MISSILE_FLAG] > 30)
                d = 30-(rockets[i][MISSILE_FLAG]-30);
            if (d < 0) {
                d = 0;
                rockets[i][MISSILE_FLAG] = 0;
            }
            DrawCircle(rockets[i][MISSILE_X], rockets[i][MISSILE_Y], d, GREEN);
        }
    }
    
    int missiles_left = 0;
    for (int i = 0; i < 12; i++) {
        if (missiles[i][MISSILE_FLAG] == 1) {
            float r = atan2(450-missiles[i][MISSILE_Y], missiles[i][MISSILE_TOX]-missiles[i][MISSILE_X]);
            missiles[i][MISSILE_X] += cos(r)*missiles[i][MISSILE_SPEED]*GetFrameTime();
            missiles[i][MISSILE_Y] += sin(r)*missiles[i][MISSILE_SPEED]*GetFrameTime();
            float x=missiles[i][MISSILE_X],y=missiles[i][MISSILE_Y];
            
            for (int j = 0; j < 8; j++) {
                if (rockets[j][MISSILE_FLAG] > 2) {
                    float d = rockets[j][MISSILE_FLAG];
                    if (rockets[j][MISSILE_FLAG] > 30)
                        d = 30-(rockets[j][MISSILE_FLAG]-30);
                    if (distance(missiles[i][MISSILE_X], missiles[i][MISSILE_Y], rockets[j][MISSILE_X], rockets[j][MISSILE_Y]) < d) {
                        missiles[i][MISSILE_FLAG] = 2;
                        score++;
                    }
                }
            }
            
            for (int j = 0; j < 12; j++) {
                if (i == j) continue;
                if (missiles[j][MISSILE_FLAG] > 2) {
                    float d = missiles[j][MISSILE_FLAG];
                    if (missiles[j][MISSILE_FLAG] > 30)
                        d = 30-(missiles[j][MISSILE_FLAG]-30);
                    if (distance(missiles[i][MISSILE_X], missiles[i][MISSILE_Y], missiles[j][MISSILE_X], missiles[j][MISSILE_Y]) < d) {
                        missiles[i][MISSILE_FLAG] = 2;
                        score++;
                    }
                }
            }
            
            for (int j=0; j < 3; j++) {
                int a=cities[j][0],b=450;
                if (x > a-city_width/2 && x < a+city_width/2 && y > b && y < b+15) {
                    cities[j][CITY_FLAG] = 0;
                    missiles[i][MISSILE_FLAG] = 0;
                    score--;
                }
            }
            
            DrawLine(missiles[i][MISSILE_FROMX], 0, missiles[i][MISSILE_X], missiles[i][MISSILE_Y], RED);
        } else if (missiles[i][MISSILE_FLAG] > 1) {
            missiles[i][MISSILE_FLAG] += 50*GetFrameTime();
            float d = missiles[i][MISSILE_FLAG];
            if (missiles[i][MISSILE_FLAG] > 30)
                d = 30-(missiles[i][MISSILE_FLAG]-30);
            if (d < 0) {
                d = 0;
                missiles[i][MISSILE_FLAG] = 0;
            }
            DrawCircle(missiles[i][MISSILE_X], missiles[i][MISSILE_Y], d, RED);
        }
        if (missiles[i][MISSILE_FLAG] > 0) {
            missiles_left++;
        }
    }
    
    if (missiles_left == 0 && !new_wave) {
        new_wave = true;
        if (difficulty < 9)
            difficulty++;
    }
    
    int cities_left = 0;
    for (int i = 0; i < 3; i++) {
        if (cities[i][CITY_FLAG] == 1) {
            DrawRectangle(cities[i][CITY_X]-city_width/2, 450, city_width, 15, BLUE);
            cities_left++;
        }
    }
    
    if (score < 0) score = 0;
    
    if (cities_left == 0) {
        dead = true;
        if (score > highscores[SCORE_MISSILES]) {
            highscores[SCORE_MISSILES] = score;
            dump_scores();
        }
        goto M_DEAD;
    }
    
    DrawRectangle(cursor_x-1, cursor_y-10, 3, 8, WHITE);
    DrawRectangle(cursor_x-10, cursor_y-1, 8, 3, WHITE);
    DrawRectangle(cursor_x-1, cursor_y+2, 3, 8, WHITE);
    DrawRectangle(cursor_x+2, cursor_y-1, 8, 3, WHITE);
    
    M_DEAD:
    if (dead) {
        DrawText("You died", 100, 150, 40, RED);
        DrawText(FormatText("Score: %d", score), 100, 200, 40, RED);
        DrawText("R to restart", 100, 250, 40, GREEN);
        DrawText("Q to exit", 100, 300, 40, GREEN);
    }
    
    // DrawText("PLAYING MISSILES", 50, 150, 40, (Color){0, 255, 255, 255});
}

int main(int argc, char** argv)
{
    srand(time(NULL));
    
    read_scores();
    
    InitWindow(640, 480, "1 Class Jam");
    SetTargetFPS(60);
    SetExitKey(KEY_F12);
    
    SetMousePosition((Vector2){0, 0});
    
    Shader light = LoadShader("assets/light.vs", "assets/light.fs");
    light.locs[LOC_MATRIX_MODEL] = GetShaderLocation(light, "modelMatrix");
    
    cabinet_model = LoadModel("assets/cabinet2.obj");
    cabinet_model.material.maps[MAP_DIFFUSE].texture = LoadTexture("assets/Cabinet2.png");
    cabinet_model.material.shader = light;
    
    cabinet_joystick = LoadModel("assets/joystick.obj");
    cabinet_joystick.material.maps[MAP_DIFFUSE].texture = LoadTexture("assets/Joystick.png");
    cabinet_joystick.material.shader = light;
    
    Mesh cabinet_mesh = GenMeshPlane(1.663860, 1.275940, 1, 1);
    cabinet_screen = LoadModelFromMesh(cabinet_mesh);
    cabinet_screen.material.shader = LoadShader("assets/light.vs", NULL);
    
    cabinet_target = LoadRenderTexture(512, 512);
    SetTextureFilter(cabinet_target.texture, FILTER_POINT);
    
    cabinet_buffer = LoadRenderTexture(512, 512);
    SetTextureFilter(cabinet_buffer.texture, FILTER_POINT);
    
    camera = (Camera){{3.f, 3.6f, 3.f}, {0.f,3.f, 0.f}, {0.f, 1.f, 0.f}, 90.f};
    SetCameraMode(camera, CAMERA_FIRST_PERSON);
    
    int temp_x,temp_y;
    
    while (!WindowShouldClose())
    {
        if (!playing) {
            if (IsKeyPressed(KEY_E)) {
                playing = true;
                temp_x = GetMouseX();
                temp_y = GetMouseY();
            }
            else /* Because of a minor graphical bug */
                UpdateCamera(&camera);
        } else {
            if (IsKeyPressed(KEY_ESCAPE)) {
                playing = false;
                SetMousePosition((Vector2){temp_x, temp_y});
            }
        }
        
        BeginDrawing();
        
            ClearBackground(BLACK);
            
            BeginTextureMode(cabinet_target);
                ClearBackground((Color){10, 10, 10, 255});
                switch(current_game)
                {
                    case GAME_LIST:
                        game_list();
                        break;
                    case GAME_SCORES:
                        game_scores();
                        break;
                    case GAME_SNAKE:
                        game_snake();
                        break;
                    case GAME_BREAKOUT:
                        game_breakout();
                        break;
                    case GAME_MISSILES:
                        game_missiles();
                        break;
                    default:
                        break;
                }
            EndTextureMode();
            
            /* Cheap hack because textures get inverted on planes for some reason */
            BeginTextureMode(cabinet_buffer);
                DrawTextureRec(cabinet_target.texture, (Rectangle){0, 0, -512, -512}, (Vector2){0, 0}, WHITE);
            EndTextureMode();
            
            Begin3dMode(camera);
                DrawModel(cabinet_model, (Vector3){0, 0, 0}, 1.f, WHITE);
                
                float rx = 0;
                float rz = 0;
                if (IsKeyDown(KEY_UP))         rx = 5;
                else if (IsKeyDown(KEY_DOWN))  rx = -5;
                if (IsKeyDown(KEY_LEFT))       rz = -5;
                else if (IsKeyDown(KEY_RIGHT)) rz = 5;
                
                Matrix m = MatrixIdentity();
                m = MatrixMultiply(m, MatrixRotateX(rx*DEG2RAD));
                m = MatrixMultiply(m, MatrixRotateZ(rz*DEG2RAD));
                cabinet_joystick.transform = m;
                DrawModel(cabinet_joystick, (Vector3){-0.002223, 2.79611, 0.690871}, 1.f, WHITE);
                
                m = MatrixIdentity();
                m = MatrixMultiply(m, MatrixRotateX(19.6*DEG2RAD));
                m = MatrixMultiply(m, MatrixRotateY(180*DEG2RAD));
                cabinet_screen.transform = m;
                cabinet_screen.material.maps[MAP_DIFFUSE].texture = cabinet_buffer.texture;
                DrawModel(cabinet_screen, (Vector3){-0.003, 2.93800, -0.251312}, 1.f, WHITE);
            End3dMode();
            
        EndDrawing();
    }
    
    UnloadModel(cabinet_model);
    UnloadModel(cabinet_screen);
    UnloadRenderTexture(cabinet_target);
    UnloadRenderTexture(cabinet_buffer);
    
    CloseWindow();
    
    return 0;
}
